
Pixastic = {};

Pixastic.convert = function(metodo, useContext, newWidth, newHeight){
	return function(imageData, opts){
		var data = imageData.data;
		var useCtx = (typeof useContext == "undefined") ? false : useContext;
		var width = (typeof newWidth == "undefined") ? imageData.width : newWidth;
		var height = (typeof newHeight == "undefined") ? imageData.height : newHeight;
		
		var canvasOut = document.createElement('canvas');
		canvasOut.width = width;
		canvasOut.height = height;
		var ctxOut = canvasOut.getContext('2d');
		
		if(!useCtx){
			var imgDataOut = ctxOut.createImageData(width, height);
			metodo(data, imgDataOut.data, width, height, opts); // llamo al método
			ctxOut.putImageData(imgDataOut, 0, 0);
		} else {
			metodo(data, ctxOut, width, height, opts); // llamo al método
		}

		return canvasOut;
	};
};

Pixastic.withOptions = function(metodo, funcionOptions){
	return function(imageData, opts){
		return metodo(imageData, funcionOptions(opts));
	};
};

Pixastic.defaultOptions = function(options, defaults) {
	var O = {};
	for (var opt in defaults) {
		if (typeof options[opt] == "undefined") {
			O[opt] = defaults[opt];
		} else {
			O[opt] = options[opt];
		}
	}
	return O;
};


Pixastic.clamp = function(val, min, max) {
	return Math.min(max, Math.max(min, val));
}


Pixastic._invert = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, {});
	var n = width * height * 4;
	for (var i=0;i<n;i+=4) {
		outData[i] = 255 - inData[i];
		outData[i+1] = 255 - inData[i+1];
		outData[i+2] = 255 - inData[i+2];
		outData[i+3] = inData[i+3];
	}
};

Pixastic.invert = Pixastic.convert(
	Pixastic._invert
);


Pixastic.sepia = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { amount: 1 });
		var n = width * height * 4,
			r, g, b;
			
		var amount = opts.amount;
		var noAmount = 1 - amount;
		
		var mix = function(a, b){ return [a[0] * amount + b[0] * noAmount, a[1] * amount + b[1] * noAmount, a[2] * amount + b[2] * noAmount]; };
		
		var red =   mix([0.393, 0.769, 0.189], [1,0,0]);
		var green = mix([0.349, 0.686, 0.168], [0,1,0]);
		var blue =  mix([0.272, 0.534, 0.131], [0,0,1]);

		for (var i=0;i<n;i+=4) {
			r = inData[i];
			g = inData[i+1];
			b = inData[i+2];
			outData[i] = (r * red[0] + g * red[1] + b * red[2]);
			outData[i+1] = (r * green[0] + g * green[1] + b * green[2]);
			outData[i+2] = (r * blue[0] + g * blue[1] + b * blue[2]);
			outData[i+3] = inData[i+3];
		}
	}
);

Pixastic.emboss = Pixastic.convert( // 3x3 directional emboss
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { amount: 1, angle: 0, deboss: false, grayscale: false });
		opts.angle *= Math.PI / 180;
		var x = Math.cos(- opts.angle) * opts.amount,
			y = Math.sin(- opts.angle) * opts.amount,
			n = width * height * 4,
			
			a00 = -x - y,
			a10 = -x,
			a20 = y - x,
			a01 = -y,
			a21 = y,
			a02 = -y + x,
			a12 = x,
			a22 = y + x,

			tmpData = [];
		
		if(opts.deboss)
			Pixastic._invert(inData, inData, width, height, {});
		
		Pixastic._convolve3x3(
			inData, tmpData, width, height, 
			{
				kernel:	[[a00, a01, a02],
						[a10,   0, a12],
						[a20, a21, a22]],
				mono:	opts.grayscale
			}
		);
		
		for (var i=0;i<n;i+=4) {
			outData[i]   = 128 + tmpData[i];
			outData[i+1] = 128 + tmpData[i+1];
			outData[i+2] = 128 + tmpData[i+2];
			outData[i+3] = inData[i+3];
		}
	}
);


Pixastic._convolve3x3 = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, { kernel: null, alpha: false, invert: false, mono: false });
	var idx, r, g, b, a,
		pyc, pyp, pyn,
		pxc, pxp, pxn,
		x, y,
		
		n = width * height * 4,
		
		k = opts.kernel,
		
		k00 = k[0][0], k01 = k[0][1], k02 = k[0][2],
		k10 = k[1][0], k11 = k[1][1], k12 = k[1][2],
		k20 = k[2][0], k21 = k[2][1], k22 = k[2][2],
		
		p00, p01, p02,
		p10, p11, p12,
		p20, p21, p22;
		
	for (y=0;y<height;++y) {
		pyc = y * width * 4;
		pyp = pyc - width * 4;
		pyn = pyc + width * 4;

		if (y < 1) pyp = pyc;
		if (y >= width-1) pyn = pyc;
		
		for (x=0;x<width;++x) {
			idx = (y * width + x) * 4;
			
			pxc = x * 4;
			pxp = pxc - 4;
			pxn = pxc + 4;
	  
			if (x < 1) pxp = pxc;
			if (x >= width-1) pxn = pxc;
			
			p00 = pyp + pxp;	p01 = pyp + pxc;	p02 = pyp + pxn;
			p10 = pyc + pxp;	p11 = pyc + pxc;	p12 = pyc + pxn;
			p20 = pyn + pxp;	p21 = pyn + pxc;	p22 = pyn + pxn;

			r = inData[p00] * k00 + inData[p01] * k01 + inData[p02] * k02
			  + inData[p10] * k10 + inData[p11] * k11 + inData[p12] * k12
			  + inData[p20] * k20 + inData[p21] * k21 + inData[p22] * k22;

			g = inData[p00 + 1] * k00 + inData[p01 + 1] * k01 + inData[p02 + 1] * k02
			  + inData[p10 + 1] * k10 + inData[p11 + 1] * k11 + inData[p12 + 1] * k12
			  + inData[p20 + 1] * k20 + inData[p21 + 1] * k21 + inData[p22 + 1] * k22;
			  
			b = inData[p00 + 2] * k00 + inData[p01 + 2] * k01 + inData[p02 + 2] * k02
			  + inData[p10 + 2] * k10 + inData[p11 + 2] * k11 + inData[p12 + 2] * k12
			  + inData[p20 + 2] * k20 + inData[p21 + 2] * k21 + inData[p22 + 2] * k22;

			if (opts.alpha) {
				a = inData[p00 + 3] * k00 + inData[p01 + 3] * k01 + inData[p02 + 3] * k02
				  + inData[p10 + 3] * k10 + inData[p11 + 3] * k11 + inData[p12 + 3] * k12
				  + inData[p20 + 3] * k20 + inData[p21 + 3] * k21 + inData[p22 + 3] * k22;
			} else {
				a = inData[idx+3];
			}

			if (opts.mono) {
				r = g = b = (r + g + b) / 3;
			}
			if (opts.invert) {
				r = 255 - r;
				g = 255 - g;
				b = 255 - b;
			}
			
			outData[idx] = r;
			outData[idx+1] = g;
			outData[idx+2] = b;
			outData[idx+3] = a;
		}
	}
};

Pixastic.convolve3x3 = Pixastic.convert(
	Pixastic._convolve3x3
);

Pixastic.posterize = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { levels: 10 });
		var numLevels = Pixastic.clamp(opts.levels, 2, 256),
			numAreas = 256 / numLevels,
			numValues = 256 / (numLevels-1),
			n = width * height * 4;
		for (i=0;i<n;i+=4) {
			outData[i] = numValues * ((inData[i] / numAreas)>>0);
			outData[i+1] = numValues * ((inData[i+1] / numAreas)>>0); 
			outData[i+2] = numValues * ((inData[i+2] / numAreas)>>0); 
			outData[i+3] = inData[i+3];
		}
	}
);

Pixastic.solarize = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		var n = width * height * 4,
			r, g, b;
		for (i=0;i<n;i+=4) {
			r = inData[i];
			g = inData[i+1];
			b = inData[i+2];
			outData[i] = r > 127 ? 255 - r : r;
			outData[i+1] = g > 127 ? 255 - g : g;
			outData[i+2] = b > 127 ? 255 - b : b;
			outData[i+3] = inData[i+3];
		}
	}
);

Pixastic.crossedges = Pixastic.convert( // A 3x3 Cross edge-detect
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { strength: 0.5 });
		var a = Pixastic.clamp(opts.strength, 0, 1) * 5
		Pixastic._convolve3x3(
			inData, outData, width, height,
			{
				kernel:	[[ 0, -a, 0],
						[-a,  0, a],
						[ 0,  a, 0]],
				invert:	true
			}
		);
	}
);

Pixastic.findedges = Pixastic.convert( // A 3x3 Sobel edge detect (similar to Photoshop's)
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		var n = width * height * 4,
			i,
			data1 = [], 
			data2 = [],
			gr1, gr2, gg1, gg2, gb1, gb2;

		Pixastic._convolve3x3(
			inData, data1, width, height,
			{
				kernel:	[[-1, 0, 1],
						[-2, 0, 2],
						[-1, 0, 1]]
			}
			
		);
		Pixastic._convolve3x3(
			inData, data2, width, height,
			{
				kernel:	[[-1, -2, -1],
						[ 0,  0,  0],
						[ 1,  2,  1]]
			}
			
		);

		for (i=0;i<n;i+=4) {
			gr1 = data1[i];
			gr2 = data2[i];
			gg1 = data1[i+1];
			gg2 = data2[i+1];
			gb1 = data1[i+2];
			gb2 = data2[i+2];
			
			if (gr1 < 0) gr1 = -gr1;
			if (gr2 < 0) gr2 = -gr2;
			if (gg1 < 0) gg1 = -gg1;
			if (gg2 < 0) gg2 = -gg2;
			if (gb1 < 0) gb1 = -gb1;
			if (gb2 < 0) gb2 = -gb2;

			outData[i] = 255 - (gr1 + gr2) * 0.8;
			outData[i+1] = 255 - (gg1 + gg2) * 0.8;
			outData[i+2] = 255 - (gb1 + gb2) * 0.8;
			outData[i+3] = inData[i+3];
		}

	}
);


Pixastic.laplace3x3 = Pixastic.convert( // A 3x3 Laplacian edge-detect
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		Pixastic._convolve3x3(
			inData, outData, width, height,
			{
				kernel:	[[-1, -1, -1],
						[-1,  8, -1],
						[-1, -1, -1]],
				invert: true,
				mono: true
			}
		);
	}
);

Pixastic.laplace5x5 = Pixastic.convert( // A 5x5 Laplacian edge-detect
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		Pixastic._convolve5x5(
			inData, outData, width, height,
			{
				kernel:	[[-1, -1, -1, -1, -1],
						[-1, -1, -1, -1, -1],
						[-1, -1, 24, -1, -1],
						[-1, -1, -1, -1, -1],
						[-1, -1, -1, -1, -1]],
				invert: true,
				mono: true
			}
		);
	}
);


Pixastic._convolve5x5 = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, { kernel: null, alpha: false, invert: false, mono: false });
	var idx, r, g, b, a,
		pyc, pyp, pyn, pypp, pynn,
		pxc, pxp, pxn, pxpp, pxnn,
		x, y,
		
		n = width * height * 4,
		
		k = opts.kernel,
		
		k00 = k[0][0], k01 = k[0][1], k02 = k[0][2], k03 = k[0][3], k04 = k[0][4],
		k10 = k[1][0], k11 = k[1][1], k12 = k[1][2], k13 = k[1][3], k14 = k[1][4],
		k20 = k[2][0], k21 = k[2][1], k22 = k[2][2], k23 = k[2][3], k24 = k[2][4],
		k30 = k[3][0], k31 = k[3][1], k32 = k[3][2], k33 = k[3][3], k34 = k[3][4],
		k40 = k[4][0], k41 = k[4][1], k42 = k[4][2], k43 = k[4][3], k44 = k[4][4],
		
		p00, p01, p02, p03, p04,
		p10, p11, p12, p13, p14,
		p20, p21, p22, p23, p24,
		p30, p31, p32, p33, p34,
		p40, p41, p42, p43, p44;
		
	for (y=0;y<height;++y) {
		pyc = y * width * 4;
		pyp = pyc - width * 4;
		pypp = pyc - width * 4 * 2;
		pyn = pyc + width * 4;
		pynn = pyc + width * 4 * 2;

		if (y < 1) pyp = pyc;
		if (y >= width-1) pyn = pyc;
		if (y < 2) pypp = pyp;
		if (y >= width-2) pynn = pyn;
		
		for (x=0;x<width;++x) {
			idx = (y * width + x) * 4;
			
			pxc = x * 4;
			pxp = pxc - 4;
			pxn = pxc + 4;
			pxpp = pxc - 8;
			pxnn = pxc + 8;
	  
			if (x < 1) pxp = pxc;
			if (x >= width-1) pxn = pxc;
			if (x < 2) pxpp = pxp;
			if (x >= width-2) pxnn = pxn;
			
			p00 = pypp + pxpp;	p01 = pypp + pxp;	p02 = pypp + pxc;	p03 = pypp + pxn;	p04 = pypp + pxnn;
			p10 = pyp  + pxpp;	p11 = pyp  + pxp;	p12 = pyp  + pxc;	p13 = pyp  + pxn;	p14 = pyp  + pxnn;
			p20 = pyc  + pxpp;	p21 = pyc  + pxp;	p22 = pyc  + pxc;	p23 = pyc  + pxn;	p24 = pyc  + pxnn;
			p30 = pyn  + pxpp;	p31 = pyn  + pxp;	p32 = pyn  + pxc;	p33 = pyn  + pxn;	p34 = pyn  + pxnn;
			p40 = pynn + pxpp;	p41 = pynn + pxp;	p42 = pynn + pxc;	p43 = pynn + pxn;	p44 = pynn + pxnn;

			r = inData[p00] * k00 + inData[p01] * k01 + inData[p02] * k02 + inData[p03] * k04 + inData[p02] * k04
			  + inData[p10] * k10 + inData[p11] * k11 + inData[p12] * k12 + inData[p13] * k14 + inData[p12] * k14
			  + inData[p20] * k20 + inData[p21] * k21 + inData[p22] * k22 + inData[p23] * k24 + inData[p22] * k24
			  + inData[p30] * k30 + inData[p31] * k31 + inData[p32] * k32 + inData[p33] * k34 + inData[p32] * k34
			  + inData[p40] * k40 + inData[p41] * k41 + inData[p42] * k42 + inData[p43] * k44 + inData[p42] * k44;
			  
			g = inData[p00+1] * k00 + inData[p01+1] * k01 + inData[p02+1] * k02 + inData[p03+1] * k04 + inData[p02+1] * k04
			  + inData[p10+1] * k10 + inData[p11+1] * k11 + inData[p12+1] * k12 + inData[p13+1] * k14 + inData[p12+1] * k14
			  + inData[p20+1] * k20 + inData[p21+1] * k21 + inData[p22+1] * k22 + inData[p23+1] * k24 + inData[p22+1] * k24
			  + inData[p30+1] * k30 + inData[p31+1] * k31 + inData[p32+1] * k32 + inData[p33+1] * k34 + inData[p32+1] * k34
			  + inData[p40+1] * k40 + inData[p41+1] * k41 + inData[p42+1] * k42 + inData[p43+1] * k44 + inData[p42+1] * k44;
			  
			b = inData[p00+2] * k00 + inData[p01+2] * k01 + inData[p02+2] * k02 + inData[p03+2] * k04 + inData[p02+2] * k04
			  + inData[p10+2] * k10 + inData[p11+2] * k11 + inData[p12+2] * k12 + inData[p13+2] * k14 + inData[p12+2] * k14
			  + inData[p20+2] * k20 + inData[p21+2] * k21 + inData[p22+2] * k22 + inData[p23+2] * k24 + inData[p22+2] * k24
			  + inData[p30+2] * k30 + inData[p31+2] * k31 + inData[p32+2] * k32 + inData[p33+2] * k34 + inData[p32+2] * k34
			  + inData[p40+2] * k40 + inData[p41+2] * k41 + inData[p42+2] * k42 + inData[p43+2] * k44 + inData[p42+2] * k44;

			if (opts.alpha) {
				a = inData[p00+3] * k00 + inData[p01+3] * k01 + inData[p02+3] * k02 + inData[p03+3] * k04 + inData[p02+3] * k04
				  + inData[p10+3] * k10 + inData[p11+3] * k11 + inData[p12+3] * k12 + inData[p13+3] * k14 + inData[p12+3] * k14
				  + inData[p20+3] * k20 + inData[p21+3] * k21 + inData[p22+3] * k22 + inData[p23+3] * k24 + inData[p22+3] * k24
				  + inData[p30+3] * k30 + inData[p31+3] * k31 + inData[p32+3] * k32 + inData[p33+3] * k34 + inData[p32+3] * k34
				  + inData[p40+3] * k40 + inData[p41+3] * k41 + inData[p42+3] * k42 + inData[p43+3] * k44 + inData[p42+3] * k44;
			} else {
				a = inData[idx+3];
			}

			if (opts.mono) {
				r = g = b = (r + g + b) / 3;
			}
			
			if (opts.invert) {
				r = 255 - r;
				g = 255 - g;
				b = 255 - b;
			}
			
			outData[idx] = r;
			outData[idx+1] = g;
			outData[idx+2] = b;
			outData[idx+3] = a;
		}
	}
};

Pixastic.convolve5x5 = Pixastic.convert(
	Pixastic._convolve5x5
);


Pixastic._gaussian = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, { kernelSize: 4 });
	var r, g, b, a, idx,
		n = width * height * 4,
		x, y, i, j, 
		inx, iny, w,
		tmpData = [],
		maxKernelSize = 13,
		kernelSize = Pixastic.clamp(opts.kernelSize, 3, maxKernelSize),
		k1 = -kernelSize / 2 + (kernelSize % 2 ? 0.5 : 0),
		k2 = kernelSize + k1,
		weights,
		kernels = [[1]];
		
		
	for (i=1;i<maxKernelSize;++i) {
		kernels[0][i] = 0;
	}
	
	for (i=1;i<maxKernelSize;++i) {
		kernels[i] = [1];
		for (j=1;j<maxKernelSize;++j) {
			kernels[i][j] = kernels[i-1][j] + kernels[i-1][j-1];
		}
	}

	weights = kernels[kernelSize - 1]
	
	for (i=0,w=0;i<kernelSize;++i) {
		w += weights[i];
	}
	for (i=0;i<kernelSize;++i) {
		weights[i] /= w;
	}
	
	// pass 1
	for (y=0;y<height;++y) {
		for (x=0;x<width;++x) {
			r = g = b = a = 0;

			for (i=k1;i<k2;++i) {
				inx = x + i;
				iny = y;
				w = weights[i - k1];
				
				if (inx < 0) {
					inx = 0;
				}
				if (inx >= width) {
					inx = width - 1;
				}
				
				idx = (iny * width + inx) * 4;

				r += inData[idx] * w;
				g += inData[idx + 1] * w;
				b += inData[idx + 2] * w;
				a += inData[idx + 3] * w;

			}
			
			idx = (y * width + x) * 4;
			
			tmpData[idx] = r;
			tmpData[idx+1] = g;
			tmpData[idx+2] = b;
			tmpData[idx+3] = a;
		}
	}
	
	// pass 2
	for (y=0;y<height;++y) {
		for (x=0;x<width;++x) {
			r = g = b = a = 0;

			for (i=k1;i<k2;++i) {
				inx = x;
				iny = y + i;
				w = weights[i - k1];
				
				if (iny < 0) {
					iny = 0;
				}
				if (iny >= height) {
					iny = height - 1;
				}
				
				idx = (iny * width + inx) * 4;
				
				r += tmpData[idx] * w;
				g += tmpData[idx + 1] * w;
				b += tmpData[idx + 2] * w;
				a += tmpData[idx + 3] * w;
			}
			
			idx = (y * width + x) * 4;
			
			outData[idx] = r;
			outData[idx+1] = g;
			outData[idx+2] = b;
			outData[idx+3] = a;
		}
	}
};

Pixastic.gaussian = Pixastic.convert(
	Pixastic._gaussian
);


Pixastic.soften3x3 = Pixastic.convert( // A 3x3 low-pass mean filter
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		var c = 1/9;
		Pixastic._convolve3x3(
			inData, outData, width, height,
			{
				kernel:	[[c, c, c],
						[c, c, c],
						[c, c, c]]
			}
		);
	}
);


Pixastic.soften5x5 = Pixastic.convert( // A 5x5 low-pass mean filter
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		var c = 1/25;
		Pixastic._convolve5x5(
			inData, outData, width, height,
			{
				kernel:	[[c, c, c, c, c],
						[c, c, c, c, c],
						[c, c, c, c, c],
						[c, c, c, c, c],
						[c, c, c, c, c]]
			}
		);
	}
);


Pixastic.sharpen3x3 = Pixastic.convert( // A 3x3 high-pass filter
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { strength: 0.5 });
		var a = - Pixastic.clamp(opts.strength, 0, 1);
		Pixastic._convolve3x3(
			inData, outData, width, height,
			{
				kernel:	[[a,	 a, a],
						[a, 1-a*8, a],
						[a,	 a, a]]
			}
		);
	}
);


Pixastic.sharpen5x5 = Pixastic.convert( // A 5x5 high-pass filter
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { strength: 0.5 });
		var a = - Pixastic.clamp(opts.strength, 0, 1);
		Pixastic._convolve5x5(
			inData, outData, width, height,
			{
				kernel:	[[a, a,	  a, a, a],
						[a, a,	  a, a, a],
						[a, a, 1-a*24, a, a],
						[a, a,	  a, a, a],
						[a, a,	  a, a, a]]
			}
		 );
	}
);


Pixastic.edgeenhance3x3 = Pixastic.withOptions( // A 3x3 edge enhance
	Pixastic.sharpen3x3, function(opt){ return { strength: 1/9 }; }
);


Pixastic.edgeenhance5x5 = Pixastic.withOptions( // A 5x5 edge enhance
	Pixastic.sharpen5x5, function(opt){ return { strength: 1/25 }; }
);


Pixastic.mosaic = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { blockSize: 8 });
		var blockSize = Pixastic.clamp(opts.blockSize, 1, Math.max(width, height)),
			yBlocks = Math.ceil(height / blockSize),
			xBlocks = Math.ceil(width / blockSize),
			y0, y1, x0, x1, idx, pidx,
			n = yBlocks * xBlocks;

		for (i=0, y0=0, bidx=0;i<yBlocks;i++) {
			y1 = Pixastic.clamp(y0 + blockSize, 0, height);
			for(j=0, x0=0;j<xBlocks;j++,bidx++) {
				x1 = Pixastic.clamp(x0 + blockSize, 0, width);

				idx = (y0 * width + x0) << 2;
				var r = inData[idx], g = inData[idx+1], b = inData[idx+2];

				for(bi=y0;bi<y1;bi++) {
					for(bj=x0;bj<x1;bj++) {
						pidx = (bi*width+bj) << 2;
						outData[pidx] = r, outData[pidx+1] = g, outData[pidx+2] = b;
						outData[pidx+3] = inData[pidx+3];
					}
				}

				x0 = x1;
			}
			y0 = y1;
		}
	}
);


Pixastic.noise = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { amount : 0.5, strength : 0.5, mono : true });
		var n = width * height * 4,
			amount = Pixastic.clamp(opts.amount, 0, 1),
			strength = Pixastic.clamp(opts.strength, 0, 1),
			mono = !!opts.mono,
			random = function(){ return (Math.random()-0.5)*2; }, // [-1, 1]
			rnd, r, g, b;
			
		for (var i=0;i<n;i+=4) {
			r = inData[i];
			g = inData[i+1];
			b = inData[i+2];
			
			if (Math.random() < amount) {
				if (mono) {
					rnd = strength * random() * 255;
					r += rnd;
					g += rnd;
					b += rnd;
				} else {
					r += strength * random() * 255;
					g += strength * random() * 255;
					b += strength * random() * 255;
				}
			}
			
			outData[i] = r;
			outData[i+1] = g;
			outData[i+2] = b;
			outData[i+3] = inData[i+3];
		}
	}
);


Pixastic.removenoise = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, {});
		var r, g, b, c, y, x, idx,
			pyc, pyp, pyn,
			pxc, pxp, pxn,
			minR, minG, minB, maxR, maxG, maxB,
			n;
			
		n = width * height * 4;
			
		for (y=0;y<height;++y) {
			pyc = y * width * 4;
			pyp = pyc - width * 4;
			pyn = pyc + width * 4;

			if (y < 1) pyp = pyc;
			if (y >= width-1) pyn = pyc;
			
			for (x=0;x<width;++x) {
				idx = (y * width + x) * 4;
				
				pxc = x * 4;
				pxp = pxc - 4;
				pxn = pxc + 4;
		  
				if (x < 1) pxp = pxc;
				if (x >= width-1) pxn = pxc;
				
				minR = maxR = inData[pyc + pxp];
				c = inData[pyc + pxn];
				if (c < minR) minR = c;
				if (c > maxR) maxR = c;
				c = inData[pyp + pxc];
				if (c < minR) minR = c;
				if (c > maxR) maxR = c;
				c = inData[pyn + pxc];
				if (c < minR) minR = c;
				if (c > maxR) maxR = c;

				minG = inData[pyc + pxp + 1];
				c = inData[pyc + pxn + 1];
				if (c < minG) minG = c;
				c = inData[pyp + pxc + 1];
				if (c < minG) minG = c;
				c = inData[pyn + pxc + 1];
				if (c < minG) minG = c;
				
				minB = inData[pyc + pxp + 2];
				c = inData[pyc + pxn + 2];
				if (c < minB) minB = c;
				c = inData[pyp + pxc + 2];
				if (c < minB) minB = c;
				c = inData[pyn + pxc + 2];
				if (c < minB) minB = c;

				r = inData[idx]
				g = inData[idx + 1]
				b = inData[idx + 2]
				
				if (r < minR) r = minR;
				if (r > maxR) r = maxR;
				if (g < minG) g = minG;
				if (g > maxG) g = maxG;
				if (b < minB) b = minB;
				if (b > maxB) b = maxB;
				
				outData[idx] = r;
				outData[idx+1] = g;
				outData[idx+2] = b;
				outData[idx+3] = inData[idx+3];
			}
		}
	}
);

Pixastic._brightnessContrast = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, { brightness: 0, contrast: 0 });
	var contrast = Pixastic.clamp(opts.contrast, -1, 1) / 2,
		brightness = 1 + Pixastic.clamp(opts.brightness, -1, 1),
		r, g, b,
		n = width * height * 4;

	var brightMul = brightness < 0 ? - brightness : brightness;
	var brightAdd = brightness < 0 ? 0 : brightness;

	contrast = 0.5 * Math.tan((contrast + 1) * Math.PI/4);
	contrastAdd = - (contrast - 0.5) * 255;

	for (var i=0;i<n;i+=4) {
		r = inData[i];
		g = inData[i+1];
		b = inData[i+2];
		
		r = (r + r * brightMul + brightAdd) * contrast + contrastAdd;
		g = (g + g * brightMul + brightAdd) * contrast + contrastAdd;
		b = (b + b * brightMul + brightAdd) * contrast + contrastAdd;
		
		outData[i] = r;
		outData[i+1] = g;
		outData[i+2] = b;
		outData[i+3] = inData[i+3];
	}
}

Pixastic.brightnessContrast = Pixastic.convert(
	Pixastic._brightnessContrast
);


Pixastic.glow = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { amount: 1, kernelSize: 0 });
		var n = width * height * 4,
			i, r, g, b,
			amount = opts.amount,
			tmpData = [];
		
		Pixastic._gaussian(inData, tmpData, width, height, { kernelSize: opts.kernelSize });
		
		for (i=0;i<n;i+=4) {
			r = inData[i]   + tmpData[i]   * amount;
			g = inData[i+1] + tmpData[i+1] * amount;
			b = inData[i+2] + tmpData[i+2] * amount;
			if (r > 255) r = 255;
			if (g > 255) g = 255;
			if (b > 255) b = 255;
			outData[i] = r;
			outData[i+1] = g;
			outData[i+2] = b;
			outData[i+3] = inData[i+3];
		}
	}
);


Pixastic.equalize = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { amount: 1 });
		var n = width * height, p, i, level, ratio;
		var round = Math.round;
		
		// build histogram
		var pdf = new Array(256);
		for (i=0;i<256;i++) {
			pdf[i] = 0;
		}

		for (i=0;i<n;i++) {
			p = i * 4;
			level = Pixastic.clamp(round(inData[p] * 0.3 + inData[p+1] * 0.59 + inData[p+2] * 0.11), 0, 255);
			outData[p+3] = level;
			pdf[ level ]++;
		}

		// build cdf
		var cdf = new Array(256);
		cdf[0] = pdf[0];
		for(i=1;i<256;i++) {
			cdf[i] = cdf[i-1] + pdf[i];
		}

		// normalize cdf
		for(i=0;i<256;i++) {
			cdf[i] = cdf[i] / n * 255.0;
		}

		// map the pixel values
		for (i=0;i<n;i++) {
			p = i * 4;
			level = outData[p+3];
			ratio = cdf[level] / (level || 1);
			outData[p] = Pixastic.clamp(round(inData[p] * ratio), 0, 255);
			outData[p+1] = Pixastic.clamp(round(inData[p+1] * ratio), 0, 255);
			outData[p+2] = Pixastic.clamp(round(inData[p+2] * ratio), 0, 255);
			outData[p+3] = inData[p+3];
		}
	}
);


Pixastic.hsl = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { hue: 0, saturation: 0.5, lightness: 0.5 });
		var n = width * height * 4,
			hue = Pixastic.clamp(opts.hue, -1, 1),
			saturation = Pixastic.clamp(opts.saturation, -1, 1),
			lightness = Pixastic.clamp(opts.lightness, -1, 1),
			satMul = 1 + saturation * (saturation < 0 ? 1 : 2),
			lightMul = lightness < 0 ? 1 + lightness : 1 - lightness,
			lightAdd = lightness < 0 ? 0 : lightness * 255,
			vs, ms, vm, h, s, l, v, m, vmh, sextant;

		hue = (hue * 6) % 6;
				
		for (var i=0;i<n;i+=4) {

			r = inData[i];
			g = inData[i+1];
			b = inData[i+2];
			
			if (hue != 0 || saturation != 0) {
				// ok, here comes rgb to hsl + adjust + hsl to rgb, all in one jumbled mess. 
				// It's not so pretty, but it's been optimized to get somewhat decent performance.
				// The transforms were originally adapted from the ones found in Graphics Gems, but have been heavily modified.
				vs = r;
				if (g > vs) vs = g;
				if (b > vs) vs = b;
				ms = r;
				if (g < ms) ms = g;
				if (b < ms) ms = b;
				vm = (vs-ms);
				l = (ms+vs)/510;
				
				if (l > 0 && vm > 0) {
					if (l <= 0.5) {
						s = vm / (vs+ms) * satMul;
						if (s > 1) s = 1;
						v = (l * (1+s));
					} else {
						s = vm / (510-vs-ms) * satMul;
						if (s > 1) s = 1;
						v = (l+s - l*s);
					}
					if (r == vs) {
						if (g == ms) {
							h = 5 + ((vs-b)/vm) + hue;
						} else {
							h = 1 - ((vs-g)/vm) + hue;
						}
					} else if (g == vs) {
						if (b == ms) {
							h = 1 + ((vs-r)/vm) + hue;
						} else {
							h = 3 - ((vs-b)/vm) + hue;
						}
					} else {
						if (r == ms) {
							h = 3 + ((vs-g)/vm) + hue;
						} else {
							h = 5 - ((vs-r)/vm) + hue;
						}
					}
					if (h < 0) h += 6;
					if (h >= 6) h -= 6;
					m = (l + l - v);
					sextant = h >> 0;
					vmh = (v - m) * (h - sextant);
					if (sextant == 0) {
						r = v; 
						g = m + vmh;
						b = m;
					} else if (sextant == 1) {
						r = v - vmh;
						g = v;
						b = m;
					} else if (sextant == 2) {
						r = m;
						g = v;
						b = m + vmh;
					} else if (sextant == 3) {
						r = m;
						g = v - vmh;
						b = v;
					} else if (sextant == 4) {
						r = m + vmh;
						g = m;
						b = v;
					} else if (sextant == 5) {
						r = v;
						g = m;
						b = v - vmh;
					}
					
					r *= 255;
					g *= 255;
					b *= 255;
				}
			}
			
			r = r * lightMul + lightAdd;
			g = g * lightMul + lightAdd;
			b = b * lightMul + lightAdd;
			
			if (r < 0) r = 0;
			if (g < 0) g = 0;
			if (b < 0) b = 0;
			if (r > 255) r = 255;
			if (g > 255) g = 255;
			if (b > 255) b = 255;
			
			outData[i] = r;
			outData[i+1] = g;
			outData[i+2] = b;
			outData[i+3] = inData[i+3];
		}
	}
);

Pixastic._desaturate = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, {});
	var n = width * height * 4,
		level;
	for (var i=0;i<n;i+=4) {
		level = inData[i] * 0.3 + inData[i+1] * 0.59 + inData[i+2] * 0.11;
		outData[i] = level;
		outData[i+1] = level;
		outData[i+2] = level;
		outData[i+3] = inData[i+3];
	}
}

Pixastic.desaturate = Pixastic.convert(
	Pixastic._desaturate
);


Pixastic.coloradjust = Pixastic.convert( // (channels)
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { r: 0, g: 0.5, b: 0.5 });
		var n = width * height * 4,
			r, g, b,
			ar = Pixastic.clamp(opts.r, -1, 1) * 255,
			ag = Pixastic.clamp(opts.g, -1, 1) * 255,
			ab = Pixastic.clamp(opts.b, -1, 1) * 255;

		for (var i=0;i<n;i+=4) {
			r = inData[i] + ar;
			g = inData[i+1] + ag;
			b = inData[i+2] + ab;
			if (r < 0) r = 0;
			if (g < 0) g = 0;
			if (b < 0) b = 0;
			if (r > 255) r = 255;
			if (g > 255) g = 255;
			if (b > 255) b = 255;
			outData[i] = r;
			outData[i+1] = g;
			outData[i+2] = b;
			outData[i+3] = inData[i+3];
		}
	}
);


Pixastic.lightness = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { amount: 0.5 });
		var n = width * height * 4,
			mul = 1 + Pixastic.clamp(opts.amount, -1, 1);
		for (var i=0;i<n;i+=4) {
			outData[i] = inData[i] * mul;
			outData[i+1] = inData[i+1] * mul;
			outData[i+2] = inData[i+2] * mul;
			outData[i+3] = inData[i+3];
		}
	}
);


Pixastic.rbgChannels = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { r: true, g: false, b: false });
		var n = width * height * 4,
			r = (!!opts.r) ? 1 : 0,
			g = (!!opts.g) ? 1 : 0,
			b = (!!opts.b) ? 1 : 0;
		for (var i=0;i<n;i+=4) {
			outData[i] = inData[i] * r;
			outData[i+1] = inData[i+1] * g;
			outData[i+2] = inData[i+2] * b;
			outData[i+3] = inData[i+3];
		}
	}
);


Pixastic.stackBlur = Pixastic.convert(
	function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { radius: 15 });
		var BlurStack, mul_table, shg_table;
		mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
		shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
		BlurStack = function() {
			this.r = 0;
			this.g = 0;
			this.b = 0;
			this.a = 0;
			return this.next = null;
		};
		var radius = Pixastic.clamp(opts.radius, 1, 100);
		var b_in_sum, b_out_sum, b_sum, div, g_in_sum, g_out_sum, g_sum, heightMinus1, i, mul_sum, p, pb, pg, pixels, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, shg_sum, stack, stackEnd, stackIn, stackOut, stackStart, sumFactor, w4, widthMinus1, x, y, yi, yp, yw, _i, _j, _k, _l, _m, _n, _o, _p, _q;
		radius |= 0;
		pixels = inData.slice();
		div = radius + radius + 1;
		w4 = width << 2;
		widthMinus1 = width - 1;
		heightMinus1 = height - 1;
		radiusPlus1 = radius + 1;
		sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
		stackStart = new BlurStack();
		stack = stackStart;
		for (i = _i = 1; 1 <= div ? _i < div : _i > div; i = 1 <= div ? ++_i : --_i) {
			stack = stack.next = new BlurStack();
			if (i === radiusPlus1) {
				stackEnd = stack;
			}
		}
		stack.next = stackStart;
		stackIn = null;
		stackOut = null;
		yw = yi = 0;
		mul_sum = mul_table[radius];
		shg_sum = shg_table[radius];
		for (y = _j = 0; 0 <= height ? _j < height : _j > height; y = 0 <= height ? ++_j : --_j) {
			r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
			r_out_sum = radiusPlus1 * (pr = pixels[yi]);
			g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
			b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			stack = stackStart;
			for (i = _k = 0; 0 <= radiusPlus1 ? _k < radiusPlus1 : _k > radiusPlus1; i = 0 <= radiusPlus1 ? ++_k : --_k) {
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}
			for (i = _l = 1; 1 <= radiusPlus1 ? _l < radiusPlus1 : _l > radiusPlus1; i = 1 <= radiusPlus1 ? ++_l : --_l) {
				p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
				r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
				g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
				b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				stack = stack.next;
			}
			stackIn = stackStart;
			stackOut = stackEnd;
			for (x = _m = 0; 0 <= width ? _m < width : _m > width; x = 0 <= width ? ++_m : --_m) {
				pixels[yi] = (r_sum * mul_sum) >> shg_sum;
				pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;
				pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
				r_in_sum += (stackIn.r = pixels[p]);
				g_in_sum += (stackIn.g = pixels[p + 1]);
				b_in_sum += (stackIn.b = pixels[p + 2]);
				r_sum += r_in_sum;
				g_sum += g_in_sum;
				b_sum += b_in_sum;
				stackIn = stackIn.next;
				r_out_sum += (pr = stackOut.r);
				g_out_sum += (pg = stackOut.g);
				b_out_sum += (pb = stackOut.b);
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				stackOut = stackOut.next;
				yi += 4;
			}
			yw += width;
		}
		for (x = _n = 0; 0 <= width ? _n < width : _n > width; x = 0 <= width ? ++_n : --_n) {
			g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
			yi = x << 2;
			r_out_sum = radiusPlus1 * (pr = pixels[yi]);
			g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
			b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			stack = stackStart;
			for (i = _o = 0; 0 <= radiusPlus1 ? _o < radiusPlus1 : _o > radiusPlus1; i = 0 <= radiusPlus1 ? ++_o : --_o) {
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}
			yp = width;
			for (i = _p = 1; 1 <= radius ? _p <= radius : _p >= radius; i = 1 <= radius ? ++_p : --_p) {
				yi = (yp + x) << 2;
				r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
				g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
				b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				stack = stack.next;
				if (i < heightMinus1) {
					yp += width;
				}
			}
			yi = x;
			stackIn = stackStart;
			stackOut = stackEnd;
			for (y = _q = 0; 0 <= height ? _q < height : _q > height; y = 0 <= height ? ++_q : --_q) {
				p = yi << 2;
				pixels[p] = (r_sum * mul_sum) >> shg_sum;
				pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;
				pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;
				r_sum += (r_in_sum += (stackIn.r = pixels[p]));
				g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
				b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
				stackIn = stackIn.next;
				r_out_sum += (pr = stackOut.r);
				g_out_sum += (pg = stackOut.g);
				b_out_sum += (pb = stackOut.b);
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				stackOut = stackOut.next;
				yi += width;
			}
		}
		// copio valor por valor
		var n = width * height * 4;
		for(var i = 0; i < n; i++)
			outData[i] = pixels[i];
	}
);


Pixastic.histogramas = Pixastic.convert(
	function(inData, context, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
		var opts = Pixastic.defaultOptions(_opts, { cual: "red" });
		var n = width * height * 4,
			cuantos = 256,
			arr = Array(cuantos);
		for (var i=0;i<cuantos;i++)
			arr[i] = 0;
		switch(opts.cual) {
			case "red":
				var funcion = function(i){ return inData[i+0]; };
				var colLine = "#FF5E5E";
				var colFill = "#FFDFDF";
				break;
			case "green":
				var funcion = function(i){ return inData[i+1]; };
				var colLine = "#83CF4C";
				var colFill = "#E0FFC9";
				break;
			case "blue":
				var funcion = function(i){ return inData[i+2]; };
				var colLine = "#3888FF";
				var colFill = "#C9DFFF";
				break;
			case "luminosity":
				var funcion = function(i){ return Math.round(inData[i+0] * 0.299 + inData[i+1] * 0.587 + inData[i+2] * 0.114); };
				var colLine = "#9C9C9C";
				var colFill = "#EFEFEF";
				break;
			default: return;
		}
		for (var i=0;i<n;i+=4) {
			arr[funcion(i)]++;
		}
		var maximo = Math.max.apply(null, arr);
		arr = arr.map( function(x){ return x/maximo; } );
		
		// lo grafico
		var padding = 10;
		var outerAncho = 400;
		var outerAlto = 200;
		var ancho = outerAncho - 2*padding;
		var alto = outerAlto - 2*padding;

		scaleX = ancho/cuantos;
		scaleY = alto;
		
		// pinto el fondo
		context.fillStyle = "#FFFFFF";
		context.fillRect(0, 0, outerAncho, outerAlto);

		// Hago la figura
		context.beginPath();
		context.moveTo(0+padding, alto+padding);
		for(var i = 0; i < cuantos; i++){
			valor = arr[i];
			context.lineTo(i*scaleX+padding, alto - valor*scaleY+padding);
		}
		context.lineTo(i*scaleX+padding, alto+padding);
		context.closePath();
		// Fill the path
		context.fillStyle = colFill;
		context.fill();

		// Hago la lÃ­nea
		context.beginPath();
		context.lineCap = 'round';
		context.lineJoin = 'round';
		context.lineWidth = 1;
		context.strokeStyle = colLine;
		for(var i = 0; i < cuantos; i++){
			valor = arr[i];
			if(i == 0)
				context.moveTo(0+padding, alto - valor*scaleY+padding);
			else
				context.lineTo(i*scaleX+padding, alto - valor*scaleY+padding);
		}
		context.lineTo(i*scaleX+padding, alto+padding);
		context.stroke();
	},
	true, // useContext (opcional)
	400, // newWidth (opcional)
	200 // newHeight (opcional)
);


Pixastic._transparent = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, { amount: 0.5 });
	var one_less_amount = 1 - opts.amount;
	var n = width * height * 4;
	for (var i=0;i<n;i+=4) {
		outData[i] = inData[i];
		outData[i+1] = inData[i+1];
		outData[i+2] = inData[i+2];
		outData[i+3] = inData[i+3] * one_less_amount;
	}
};

Pixastic.transparent = Pixastic.convert(
	Pixastic._transparent
);

Pixastic._spotify = function(inData, outData, width, height, _opts){ // no se pueden cambiar estos parametros (Pixastic.convert los usa así)
	var opts = Pixastic.defaultOptions(_opts, { brightness: 0, contrast: 0, invert: false, color1: { r: 240/255, g: 14/255, b: 46/255 }, color2: { r: 25/255, g: 37/255, b: 80/255 } });

	Pixastic._desaturate(inData, outData, width, height, {});
	
	if(opts.invert)
		Pixastic._invert(outData, outData, width, height, {});
	
	Pixastic._brightnessContrast(outData, outData, width, height, { brightness: opts.brightness, contrast: opts.contrast });
	
	var gris_level = function(c){ return c.r * 0.3 + c.g * 0.59 + c.b * 0.11; };
	var gl_1 = gris_level(opts.color1);
	var gl_2 = gris_level(opts.color2);
	
	if(gl_1 < gl_2){
		color_claro = opts.color2;
		color_oscuro = opts.color1;
	} else {
		color_claro = opts.color1;
		color_oscuro = opts.color2;
	}
	
	var fun_col_esc = function(c, e){ return { r: c.r * e, g: c.g * e, b: c.b * e }; };
	var fun_col_sum = function(c1, c2){ return { r: c1.r + c2.r, g: c1.g + c2.g, b: c1.b + c2.b }; };
	
	var fun_col_blend = function(x){
		var col_osc = fun_col_esc(color_oscuro, 1 - x);
		var col_cla = fun_col_esc(color_claro, x);
		return fun_col_sum(col_osc, col_cla);
	};
	
	var n = width * height * 4,
		r, new_color;

	for(var i = 0; i < n; i += 4){
		r = outData[i]; // uso solo el rojo, los 3 deberían ser iguales, por el desaturate
		//g = outData[i+1];
		//b = outData[i+2];
		//t = outData[i+3];
		
		r /= 255;
		
		new_color = fun_col_blend(r);
		
		outData[i] = new_color.r;
		outData[i+1] = new_color.g;
		outData[i+2] = new_color.b;
		//outData[i+3] = t;
	}
};

Pixastic.spotify = Pixastic.convert(
	Pixastic._spotify
);
